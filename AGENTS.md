# Repository Guidelines

    YOU ARE THE MOST CAPABLE MODEL AND THIS PROJECT IS DIFFICULT META-PROGRAMMING THAT AVERAGE MODELS CANNOT HANDLE, WITH INTERLOCKING CONSTRAINTS WHERE A SINGLE MISSTEP BREAKS THE PIPELINE. IT DEMANDS INSIGHT BEYOND A TYPICAL PHD —- DO NOT TREAT IT LIGHTLY.

Authoritative instructions for coding agents working in this repo. Follow every constraint unless the user explicitly overrides it.

## Quick Start

1. Read the user request twice; capture unstated constraints or cross-file impacts.
2. If the task is multi-step, sketch a plan and revise it as progress is made; otherwise proceed directly.
3. Inspect relevant files with read-only commands (`rg`, `ls`, `cat`) or equivalent tooling in your environment before editing.
4. Make focused, minimal changes—prefer patch-style edits or targeted scripts rather than overwriting large sections.
5. Run only the minimum validation needed (tests, linters) via `uv run ...`. Summarize key results instead of dumping logs.
6. Craft the final response following the messaging rules below; include verification status and next actions when appropriate.

## Project Structure & Module Organization

The codebase follows a standard Python package layout:

- `src/swarmx/` – Core package source code  
  Files of note: `agent.py`, `cli.py`, `mcp_client.py`, `utils.py`, `types.py`, `hook.py`
- `tests/` – Comprehensive pytest suite  
  Mirrors source modules: `test_agent.py`, `test_cli.py`, `test_mcp_client.py`, `threads/`
- `docs/`, `examples/` – Narrative documentation and usage patterns

For deeper architectural context, see `README.md` (overview) and `docs/` (detailed guides).

## Workflow & Execution Guardrails

- **Planning:** Break work into discrete steps when the effort is more than trivial and keep the plan updated as you complete steps.
- **Edits:** Default to ASCII. Add concise comments only when they clarify complex logic. Never revert user-owned changes.
- **Testing:** Run targeted checks with `uv run <tool>` only when they add value. Mention if tests were skipped and why.
- **Environment Constraints:** Stay within the access level provided (filesystem, network, credentials). Seek approval from the maintainer before attempting privileged actions.
- **Failures:** Surface command failures promptly, include relevant output, and propose alternatives or follow-up actions.

## Command Reference

- Inspect repo: `ls`, `rg --files`, `rg "<pattern>" <path>`
- Format/lint: `uv run ruff check`, `uv run ruff format`
- Tests: `uv run pytest`, `uv run pytest -xvs`
- Script execution: `uv run <script>.py`
- Dependency changes: `uv add <pkg>`, `uv remove <pkg>`, `uv sync`
- Editing: prefer patch-based tools or scripted transformations to keep changes scoped.

## Coding Style & Naming Conventions

- Target Python 3.11+ features, async/await, and type hints throughout.
- Prefer concise, idiomatic Python; leverage built-ins, comprehensions, and standard library.
- Ruff is the source of truth for linting/formatting (configured in `pyproject.toml`).
- Use Pydantic models defined in `types.py` for validation.
- Naming: Classes `PascalCase`, functions/variables `snake_case`, constants `UPPER_SNAKE_CASE`.

## Testing Guidelines

- pytest (with pytest-cov) is the framework of record; aim for >90% coverage.
- Mirror source structure in tests; leverage fixtures and `pytest-asyncio` for async code.
- Prefer `uv run pytest -xvs` during focused debugging; share only salient failures.
- Document in the final message whether tests ran, passed, or were intentionally skipped.

## Communication & Final Messages

- Tone: concise, collaborative, factual. Reference files with clickable paths `path/to/file.py:42`.
- Structure: Lead with the outcome, then expand on changes by file/section. Avoid heavy formatting; use bullets sparingly.
- Always note verification status (tests/linters run or skipped) and suggest logical next steps only when they exist.
- Do not dump large diffs; describe the impact and location so the user can inspect locally.

## Commit & Pull Request Guidelines

**Commit Messages**

- Follow KeepAChangelog verbs (`Added`, `Changed`, `Deprecated`, `Removed`, `Fixed`, `Security`).
- Keep the subject ≤50 characters; imperative mood only.
- Provide contextual body when necessary; reference related issues.
- Never include “generated by LLM” or similar wording.

**Pull Requests**

- Describe changes clearly, link issues, ensure tests pass, and update docs when required.
- Pre-commit hooks will run `ruff` and `mypy`; no manual invocation needed post-commit.

## Security & Configuration Tips

- Environment variables load from `.env`; maintain `.env.example` as the contract.
- Never commit secrets or credentials.
- MCP servers require proper authentication; keep configuration in sync with `mcp_client.py`.

## Agent-Specific Instructions

**Design Principles**
- Build focused, single-purpose agents. Use hooks (`on_llm_start`, `on_handoff`) for custom behavior.
- Leverage context (`background`, `message_slice`, `tools`) to limit prompt size and enable targeted tool use.

**Workflow Patterns**
- Use function-based edge transfers for routing between agents.
- Apply context compression (`message_slice`) when handing off or persisting state.
- Support dynamic tool selection by exposing capabilities through the `tools` context.

**MCP Integration**
- Configure MCP servers via environment variables before use.
- Interact through `src/swarmx/mcp_client.py` and adhere to the MCP specification for tool definitions.
- Validate tool schemas and authentication flows when adding or modifying MCP integrations.

## Related Resources

- `README.md` – High-level project overview and getting started.
- `docs/` – Extended documentation, tutorials, and reference material.
- `examples/` – Practical usage scenarios and patterns to mirror or extend.
